{"version":3,"sources":["../node_modules/lodash/noop.js","../node_modules/query-string/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/nonIterableSpread.js","../node_modules/strict-uri-encode/index.js","../node_modules/decode-uri-component/index.js","../node_modules/split-on-first/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../src/data/OperationData.ts","../../src/data/QueryData.ts","../../src/utils/useBaseQuery.ts","../../src/utils/useDeepMemo.ts","../../src/useQuery.ts","../../src/data/MutationData.ts","../../src/data/SubscriptionData.ts","../../src/ssr/RenderPromises.ts"],"names":["module","exports","strictUriEncode","require","decodeComponent","splitOnFirst","validateArrayFormatSeparator","value","length","TypeError","encode","options","strict","encodeURIComponent","decode","removeHash","input","hashStart","indexOf","slice","extract","queryStart","parseValue","parseNumbers","Number","isNaN","trim","parseBooleans","toLowerCase","parse","Object","assign","sort","arrayFormat","arrayFormatSeparator","formatter","result","key","accumulator","exec","replace","undefined","concat","newValue","split","map","item","parserForArrayFormat","ret","create","param","keys","k","reduce","Boolean","Array","isArray","keysSorter","a","b","stringify","object","index","skipNull","join","encoderForArrayFormat","objectCopy","filter","x","parseUrl","url","query","stringifyUrl","queryFromUrl","parsedQueryFromUrl","hash","getHash","queryString","arrayWithHoles","iterableToArrayLimit","nonIterableRest","arr","i","Symbol","iterator","prototype","toString","call","_arr","_n","_d","_e","_s","_i","next","done","push","err","arrayWithoutHoles","iterableToArray","nonIterableSpread","arr2","iter","from","str","charCodeAt","toUpperCase","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","left","right","tokens","match","encodedURI","replaceMap","entries","customDecodeURIComponent","string","separator","separatorIndex","_toConsumableArray","context","isMounted","previousOptions","this","getOptions","setOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","client","isNew","cleanup","verifyDocumentType","document","type","operation","onNewData","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","getQueryResult","startQuerySubscription","obsRefetch","variables","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","execute","skip","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","loading","networkStatus","ready","called","data","fetchData","ssr","obs","getCurrentResult","afterExecute","lazy","handleErrorOrCompleted","setTimeout","resetQueryStoreErrors","bind","ssrInitiated","renderPromises","ssrDisabled","fetchDisabled","disableNetworkFetches","ssrLoading","addQueryPromise","prepareObservableQueryOptions","Query","displayName","fetchPolicy","metadata","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","children","watchQuery","registerSSRObservable","newObservableQueryOptions","catch","subscription","obsQuery","subscribe","previousResult","error","resubscribeToQuery","hasOwnProperty","lastError","getLastError","lastResult","getLastResult","resetLastResults","observableQueryFields","currentResult","partial","errors","graphQLErrors","partialRefetch","onCompleted","onError","unsubscribe","OperationData","useBaseQuery","tick","forceUpdate","updatedOptions","isRendering","isRenderScheduled","queryDataRef","queryData","current","QueryData","memoFn","ref","useDeepMemo","queryResult","useQuery","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","then","response","onMutationCompleted","onMutationError","mutation","Mutation","mostRecentMutationId","optimisticResponse","update","awaitRefetchQueries","mutateOptions","mutateVariables","refetchQueries","mutationContext","ignoreResults","updateResult","isMostRecentMutation","initialize","getLoadingResult","shouldResubscribe","startSubscription","endSubscription","updateCurrentData","updateError","complete","completeSubscription","onSubscriptionData","subscriptionData","onSubscriptionComplete","queryPromises","Map","queryInfoTrie","observable","props","lookupQueryInfo","queryInstance","finish","seen","set","Promise","resolve","hasPromises","size","consumeAndAwaitPromises","promises","forEach","promise","clear","all","varMap","get","has","variablesString","JSON","info"],"mappings":"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","file":"static/js/6.d747cef0.chunk.js","sourcesContent":["/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined || (options.skipNull && value === null)) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;\n\t\t\t\tconst newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(input, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof input !== 'string') {\n\t\treturn ret;\n\t}\n\n\tinput = input.trim().replace(/^[?#&]/, '');\n\n\tif (!input) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of input.split('&')) {\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : options.arrayFormat === 'comma' ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = Object.assign({}, object);\n\tif (options.skipNull) {\n\t\tfor (const key of Object.keys(objectCopy)) {\n\t\t\tif (objectCopy[key] === undefined || objectCopy[key] === null) {\n\t\t\t\tdelete objectCopy[key];\n\t\t\t}\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (input, options) => {\n\treturn {\n\t\turl: removeHash(input).split('?')[0] || '',\n\t\tquery: parse(extract(input), options)\n\t};\n};\n\nexports.stringifyUrl = (input, options) => {\n\tconst url = removeHash(input.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(input.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl);\n\tconst hash = getHash(input.url);\n\tconst query = Object.assign(parsedQueryFromUrl, input.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}","import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  public onNewData: () => void;\n\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    onNewData\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    onNewData: () => void;\n  }) {\n    super(options, context);\n    this.onNewData = onNewData;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined\n          } as QueryResult<TData, TVariables>\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n\n      // When the component is done rendering stored query errors, we'll\n      // remove those errors from the `ObservableQuery` query store, so they\n      // aren't re-displayed on subsequent (potentially error free)\n      // requests/responses.\n      setTimeout(() => {\n        this.currentObservable.query &&\n          this.currentObservable.query.resetQueryStoreErrors();\n      });\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  public ssrInitiated() {\n    return this.context && this.context.renderPromises;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.onNewData();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (this.ssrInitiated() || fetchDisabled)) {\n      return ssrLoading;\n    }\n\n    let result;\n    if (this.ssrInitiated()) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.ssrInitiated() &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } }\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.ssrInitiated()) {\n      this.currentObservable.query = this.context!.renderPromises!.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions\n      });\n\n      if (this.ssrInitiated()) {\n        this.context?.renderPromises?.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.onNewData();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.onNewData();\n        }\n      }\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery) return;\n\n    const { data, loading, error } = obsQuery.getCurrentResult();\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { useContext, useEffect, useReducer, useRef } from 'react';\nimport {\n  getApolloContext,\n  OperationVariables,\n  QueryResult\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions, QueryOptions, QueryTuple } from '../types';\nimport { QueryData } from '../data/QueryData';\nimport { useDeepMemo } from './useDeepMemo';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n  const isRendering = useRef(true);\n  const isRenderScheduled = useRef(false);\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n  const queryData =\n    queryDataRef.current ||\n    new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryOptions<TData, TVariables>,\n      context,\n      onNewData() {\n        // When new data is received from the `QueryData` object, we want to\n        // force a re-render to make sure the new data is displayed. We can't\n        // force that re-render if we're already rendering however, so in that\n        // case we'll defer triggering a re-render until we're inside an effect\n        // hook.\n        if (!queryData.ssrInitiated() && isRendering.current) {\n          isRenderScheduled.current = true;\n        } else {\n          forceUpdate();\n        }\n      }\n    });\n\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // SSR won't trigger the effect hook below that stores the current\n  // `QueryData` instance for future renders, so we'll handle that here if\n  // the current render is happening server side.\n  if (queryData.ssrInitiated() && !queryDataRef.current) {\n    queryDataRef.current = queryData;\n  }\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: { ...updatedOptions, onError: undefined, onCompleted: undefined },\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => {\n    // We only need one instance of the `QueryData` class, so we'll store it\n    // as a ref to make it available on subsequent renders.\n    if (!queryDataRef.current) {\n      queryDataRef.current = queryData;\n    }\n\n    // If `QueryData` requested a re-render to show new data while we were\n    // in a render phase, let's handle the re-render here where it's safe to do\n    // so.\n    isRendering.current = false;\n    if (isRenderScheduled.current) {\n      isRenderScheduled.current = false;\n      forceUpdate();\n    }\n  });\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data\n  ]);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  return result;\n}\n","import { useRef } from 'react';\nimport { equal as isEqual } from '@wry/equality';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n */\nexport function useDeepMemo<TKey, TValue>(\n  memoFn: () => TValue,\n  key: TKey\n): TValue {\n  const ref = useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n","import { OperationVariables, QueryResult } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions } from './types';\nimport { useBaseQuery } from './utils/useBaseQuery';\n\nexport function useQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>\n) {\n  return useBaseQuery<TData, TVariables>(query, options, false) as QueryResult<\n    TData,\n    TVariables\n  >;\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n"],"sourceRoot":""}